import Data.List
import Data.Char


--Common functions
{-
List: 
[] !! n
head [] last []
length[] 
reverse[]
take 3 [5,4,3,2,1]  [5,4,3]  drop 3 [8,4,2,1,5,6]  [1,5,6]
maximum [] minimum []
4 `elem` [3,4,5,6]  True
a `mod` b
show n read n
zip [] []  -> [(,),(,),...]



toInt x = round x

isqrt = floor . sqrt . fromIntegral

charValue c = (fromEnum c) - 48

isPalindrome n = (show n) == reverse (show n)

isPrimeL n = 
    if n > 1 then null [ x | x <- [2..(n `div` 2)], n `mod` x == 0] 
    else False

isPrimeR n = ip n [2..((isqrt (n-1))+1)]
    where
    ip _ [] = True
    ip n (x:xs)
        | n `mod` x == 0 = False
        | otherwise = ip n xs

fibonacci n = go n 1 1
    where 
    go n f s
      | (f+s) > n = []
      | otherwise = (f+s) : go n s (f+s)

factorial 0 = 1
factorial n = n * factorial (n-1)

map (+-*/^isqrt) [] (output)
filter even [] (predicate)


Recursion
:
Ex: chain n
       | even n = n : chain (n `div` 2)
       | odd n = n : chain (n*3+1)

(x:xs)
Ex: isDivisibleBy1ToN v n = go v [1..n]
       where
       go v (x:xs)
         | v `mod` x /= 0 = False
         | null xs = True
         | otherwise = go v xs
-}


--Review from Types
{-
1. Some positive integers n have the property that the sum [ n + reverse(n) ] consists entirely of odd (decimal) digits. 
For instance, 36 + 63 = 99 and 409 + 904 = 1313. We will call such numbers reversible; so 36, 63, 409, and 904 are reversible. 
Leading zeroes are not allowed in either n or reverse(n). There are 120 reversible numbers below one-thousand.
How many reversible numbers are there below n?
-}
sumOfReverse n = n + (read (reverse (show n)))  --36 + 63 = 99
charValue c = (fromEnum c) - 48  --change a char to int
allDigitsOdd n = go (show n)  --check if each char of number is odd
  where
  go (x:xs)
    | even (charValue x) = False  --if one char of nymber is even then false
    | null xs = True  --rest list empty means true
    | otherwise = go xs  --keep recur on rest
lastDigitZero n = (last (show n)) == '0'  --take off the number that final digit is 0 
reviewT1 n = length [x | x <- [1..(n-1)], not (lastDigitZero x), allDigitsOdd (sumOfReverse x)]  --howManyRevs n


{-
2. 60 is the smallest number that can be divided by each of the numbers from 1 to 5 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 10?
-}
isDivisibleBy1ToN v n = go v [1..n]  --v: answer that will be check, need divisible by each number of n
  where
  go v (x:xs)
    | v `mod` x /= 0 = False  --v cannot divided by x, not factor return false
    | null xs = True  --list empty return true
    | otherwise = go v xs  --recur on rest of n
reviewT2 n = go n 1  --v start at 1
  where
  go n v
    | isDivisibleBy1ToN v n = v  --v: if v can be divided by [1..n] return v
    | otherwise = go n (v+1)  --recur v because this v is not big enough


{-
3. The sum of the squares of the first ten natural numbers is,
1^2 + 2^2 + ... + 10^2 = 385
The square of the sum of the first ten natural numbers is,
(1 + 2 + ... + 10)^2 = 55^2 = 3025
The difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum
-}
sumOfSquares n = sum [x^2 | x <- [1..n]] --sum map (^2) [1..n]
squareOfSums n = (sum [x | x <- [1..n]])^2
reviewT3 n = (squareOfSums n) - (sumOfSquares n)  --difference n


{-
4. The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143?
-}
isPrime n = ip n [2..((isqrt (n-1))+1)]
    where
    ip _ [] = True
    ip n (x:xs)
        | n `mod` x == 0 = False
        | otherwise = ip n xs
isqrt = floor . sqrt . fromIntegral
primeFactors n = [ x | x <- [2..n], isPrime x, n `mod` x == 0]
reviewT4 n = maximum (primeFactors n)  --maximum for largest answer


{-
5. By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
What is the 10001st prime number?
-}
primeList n = go n 1 2
  where
  go n c p  --c: count of prime  p: test number [2..]
    | c > n = []  --when prime counter greater than parameter(limit), return answer list
    | isPrime p = p : go n (c+1) (p+1)  --if p is prime then put it in answer, continue recur with c+1 because it's prime
    | otherwise = go n c (p+1)  --p is not prime, c no need +1
reviewT5 n = last (primeList n)  --recursion end at nth and return answer list, return last element in answer list



--Review from Higher Order
{-
1. The sequence of triangle numbers is generated by adding the natural numbers. 
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
Let us list the factors of the first seven triangle numbers:
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?
-}
triangleNumber n = sum [ x | x <- [1..n]]  --calculate sum [1..n]
factorsOf n = [ x | x <- [1..n], n `mod` x == 0]  
numFactorsOf n = length (factorsOf n)  --calculate how many factors of n
reviewH1 f = go 1 f  --c: check number start at 1
  where
  go c f
    | numFactorsOf (triangleNumber c) > f = triangleNumber c  --return triN c since ask first qualified number
    | otherwise = go (c+1) f  --c not big enough, recur c+1


{-
2. Collatz Sequences
We take a natural number, if that number is even, we divide it by two, if it's odd, we multiply it by 3 and then add 1
We take the resulting number and apply the same thing to it, which produces a new number and so on. 
In essence, we get a chain of numbers. It is thought that for all starting numbers, the chains finish at the number 1. 
So if we take the starting number 13, we get this sequence: 13, 40, 20, 10, 5, 16, 8, 4, 2, 1. 
13*3 + 1 equals 40. 40 divided by 2 is 20, etc. We see that the chain has 10 terms.
For all starting numbers between 1 and 100, how many chains have a length greater than 15?
-}
chain 1 = [1]  --base case
chain n  --if satisfied then add n to list and return final list
  | even n = n : chain (n `div` 2)
  | odd n = n : chain (n*3+1)
isLong xs = length xs > 15
reviewH2 n = length (go n 1)  --answerL: reviewH2L n = length [x | x<- [1..n], length (chain x) >15]
  where
  go n c  --c: check number
    | c > n = []  --c greater than limit number n, return answer list
    | isLong (chain c) = chain c : go n (c+1)  --if chain c length is greater than 15, add chain c to answer list(as one element)
    | otherwise = go n (c+1)  --recur whatever until c > n


{-
3. A number chain is created by continuously adding the square of the digits in a number 
to form a new number until it has been seen before.
For example,
44 → 32 → 13 → 10 → 1 → 1
85 → 89 → 145 → 42 → 20 → 4 → 16 → 37 → 58 → 89
Therefore any chain that arrives at 1 or 89 will become stuck in an endless loop. 
What is most amazing is that EVERY starting number will eventually arrive at 1 or 89.
How many starting numbers below ten million will arrive at 89?

tran n = sum (map (^2) (show n))
chain n 
-}
squareADigit c = ((fromEnum c)-48) ^ 2  --change a digit to an int and square it
processDigits xs = sum [ squareADigit x | x <- xs]  --sum of the square of digit list
squareDigits n = processDigits (show n)  --change number n to list, use above to get new number
generateSequence n
  | n == 1 = 1  --base case that equal 1, return 1 to answer list
  | n == 89 = 89  --base case that equal 89, return 89 to answer list
  | otherwise = generateSequence (squareDigits n)  --recur until get 1 or 89
reviewH3 n = length [x | x <- [1..(n-1)], generateSequence x == 89 ]  --check all number < n that has 89


{-
4. The palindromic number 595 is interesting because it can be written as the sum of consecutive squares: 
6^2 + 7^2 + 8^2 + 9^2 + 10^2 + 11^2 + 12^2.
There are exactly eleven palindromes below one-thousand that can be written as consecutive square sums, 
and the sum of these palindromes is 4164. 
Note that 1 = 0^2 + 1^2 has not been included as this problem is concerned with the squares of positive integers.
Find the sum of all the numbers less than 108 that are both palindromic 
and can be written as the sum of consecutive squares.
-}
isPalindrome n = (show n) == (reverse (show n))
isSumOfConsecutiveSquares n s = isocs n s 0  --t start at 0 as sum, compare with n
  where
  isocs n s t  --n: checked number; s: start number for consecutive; t: sum of [s^2, (s+1)^2, (s+2)^2..]
    | t == n = True  --t exactly equal n, return true
    | t > n = False  --t greater than n means cannot get n, return false
    | otherwise = isocs n (s+1) (t+(s*s))  --t < n, recur on s+1, renew t
listEm n s = [ x | x <- [1..n], isPalindrome x, isSumOfConsecutiveSquares x s ]  --list of number < n and satisfied both 

reviewH4 n = sort(concat (lpntacs n 1))  --concat for connect answer to 1 list, sort for look concise
  where
  lpntacs n s
    | s > (isqrt n) = []  --base case, s is start number of [1,2,..], [2,3,..],[3,4,..]...
    | (length (listEm n s)) > 0 = listEm n s : lpntacs n (s+1)  --if list(number < n and satisfied both) exist, put in answer list
    | otherwise = lpntacs n (s+1)  --recur for s+1 to check each s start number list can work or not



--Review from Module
{-
1.The prime 41, can be written as the sum of six consecutive primes: 41 = 2 + 3 + 5 + 7 + 11 + 13
This is the longest sum of consecutive primes that adds to a prime below one-hundred.
The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, equal to 953.
Which prime, below one-million, can be written as the sum of the most consecutive primes?
-}
listOfPrimes n = [ x | x <- [2..(n-1)], isPrime x]  --generate prime list below n-1
getConsecutivePrimes xs = go xs 1 (length xs)
  where
  go xs c l
    | c >= l = []  --base case, return answer list if count number greater than list length
    | isPrime (sum (take c xs)) = take c xs : go xs (c+1) l  --if sum of c consecutive primes is prime, put c primes in list
    | otherwise = go xs (c+1) l  --recur c+1 for longer consecutive primes
listAllConsecutivePrimes n = 
    concat [getConsecutivePrimes (drop x (listOfPrimes n)) | x <- [1..(n-1)] ]  --different start element to generate all satisfied list
reviewM1 n = go (listAllConsecutivePrimes n) []  --find longest consecutive primes list in big list
  where
  go (xs:xxs) longestList  --longestList: answer
    | null xxs = longestList  --rest list empty, return longest list
    | length xs > (length longestList) = go xxs xs  --current list greater than longest list, renew longest list
    | otherwise = go xxs longestList  --current not greater than longest list, no need renew longest list



--Review from Interactive
{-
1. A Pythagorean triplet is a set of three natural numbers, a < b < c, for which, a^2 + b^2 = c^2
For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
-}
reviewI1 n = [(a,b,c) | a<-[1..n], b<-[1..n] ,c<-[1..n] , a<b, b<c, (a^2+b^2) == c^2, a+b+c == 1000]


{-
2. The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
Find the sum of all the primes below two million
-}
reviewI2 n = sum [x | x <- [1..n - 1], isPrime x]


{-
3. The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: 
(i) each of the three terms are prime
(ii) each of the 4-digit numbers are permutations of one another.
There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, 
but there is one other 4-digit increasing sequence.
What 12-digit number do you form by concatenating the three terms in this sequence?
-}
listOf4DigitPrimes = [ x | x <- [1000..9999], isPrime x]
cnvt n = go n 0 0 0 0 0 0 0 0 0 0
  where
  go n d0 d1 d2 d3 d4 d5 d6 d7 d8 d9
    | n == 0 = [d0,d1,d2,d3,d4,d5,d6,d7,d8,d9]
    | n `mod` 10 == 0 = go (n `div` 10) (d0+1) d1 d2 d3 d4 d5 d6 d7 d8 d9
    | n `mod` 10 == 1 = go (n `div` 10) d0 (d1+1) d2 d3 d4 d5 d6 d7 d8 d9
    | n `mod` 10 == 2 = go (n `div` 10) d0 d1 (d2+1) d3 d4 d5 d6 d7 d8 d9
    | n `mod` 10 == 3 = go (n `div` 10) d0 d1 d2 (d3+1) d4 d5 d6 d7 d8 d9
    | n `mod` 10 == 4 = go (n `div` 10) d0 d1 d2 d3 (d4+1) d5 d6 d7 d8 d9
    | n `mod` 10 == 5 = go (n `div` 10) d0 d1 d2 d3 d4 (d5+1) d6 d7 d8 d9
    | n `mod` 10 == 6 = go (n `div` 10) d0 d1 d2 d3 d4 d5 (d6+1) d7 d8 d9
    | n `mod` 10 == 7 = go (n `div` 10) d0 d1 d2 d3 d4 d5 d6 (d7+1) d8 d9
    | n `mod` 10 == 8 = go (n `div` 10) d0 d1 d2 d3 d4 d5 d6 d7 (d8+1) d9
    | n `mod` 10 == 9 = go (n `div` 10) d0 d1 d2 d3 d4 d5 d6 d7 d8 (d9+1)
comparePermutations xs x y z = (cnvt (xs !! x))==(cnvt (xs !! y)) && (cnvt (xs !! x))==(cnvt (xs !! z))
createTuple xs x y z = ((xs !! x),( xs !! y),(xs !! z))
differenceOf3330 xs x y z = ((xs !! y)==(xs !! x)+3330) && ((xs !! z)==(xs !! y)+3330)
reviewI3 xs = go xs 0 1 2  --primePermutations' xs
  where
  go xs x y z
    | x > (length xs)-1 = []
    | y > (length xs)-1 = go xs (x+1) (x+2) z
    | z > (length xs)-1 = go xs x (y+1) (y+2)
    | comparePermutations xs x y z = createTuple xs x y z : go xs x y (z+1)
    | otherwise = go xs x y (z+1)


{-
4. n! means n × (n − 1) × ... × 3 × 2 × 1. For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27. 
Find the sum of the digits in the number 100!
-}
factorial 0 = 1
factorial n = n * factorial (n-1)
numberToIntList n = map digitToInt (show n)  --change n to list, change each digit to int
reviewI4 n = sum (numberToIntList (factorial n))  --sum of each digit in factorial number


{-
5. A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. 
For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, 28 is a perfect number.
A number n is called deficient if the sum of its proper divisors is less than n 
and it is called abundant if this sum exceeds n.
As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, 
the smallest number that can be written as the sum of two abundant numbers is 24.
It can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. 
However, this upper limit cannot be reduced any further by analysis even though it is known that 
the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.
Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
-}
getDivisors n = [ x | x <- [1..(n-1)], n `mod` x == 0]  --get n's factors list
isAbundant n = (sum (getDivisors n)) > n  --check if n is an abundant number by compare the sum its factors with n
listAbundant n = [ x | x <- [1..n], isAbundant x]  --find abundant number list that below n
isSumOfTwoAbundants n = go n (listAbundant n) 0 0  --check if n is the sum of 2 abundant numbers
  where
  go n xs f s  --xs: abundant list; f: fth number in list(outer); s: sth number in list(inner); compare 1 to [1..n], 2 to [1..n],...
    | f >= (length xs) = False  --outer checker end, return false
    | s >= (length xs) = go n xs (f+1) 0  --inner checker end, recur f+1 for next outer
    | not (isAbundant (xs !! f)) = go n xs f (s+1)  --if fth number of abundant list is not abundant, recur s+1
    | not (isAbundant (xs !! s)) = go n xs f (s+1)  --if sth number of abundant list is not abundant, recur s+1
    | (xs !! f)+(xs !! s)==n = True  --if fth number in abundant list + sth number in abundant list == check number n
    | otherwise = go n xs f (s+1)
reviewI5 n = sum [x | x<-[1..n], not (isSumOfTwoAbundants x)]